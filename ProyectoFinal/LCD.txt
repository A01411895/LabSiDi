#include <xc.inc>  
#include "config_asm.h"
PSECT myText,abs,ovrld,reloc=2,class=CODE

#define LCD_D_DIR	TRISD,A	    ; LCD data port direction
#define LCD_E		LATC,0,A    ; LCD E clock
#define LCD_E_DIR	TRISC,0,A
#define LCD_RW		LATC,1,A    ; LCD read/write line
#define LCD_RW_DIR	TRISC,1,A
#define LCD_RS		LATC,2,A    ; LCD register select line
#define LCD_RS_DIR	TRISC,2,A
#define LCD_ctl_port	LATC,A
#define ENABLER_TMR1	T1CON, 0, A
#define	BUTTON1		PORTB, 0, A
#define	BUTTON2		PORTB, 1, A
#define	BUTTON3		PORTB, 2, A
#define	BUTTON4		PORTB, 3, A


	LCD_DATA		EQU PORTD	    ; LCD data bus
	oscillator1MHz	        EQU 0b00110010
	count20ms_high	        EQU 0xEC
	count20ms_low		EQU 0x78
	timerInit20ms		EQU 0b00000010
	BANK15			EQU 15
	
	
		    ORG	0x00
		    goto main
		    ORG	0x08
		    retfie
		    ORG	0x18
		    retfie	    

main:   
	call	portsInit;	call ports initialization function
	call	LCD_init
	call	Pantalla1
	movlw	0xC8
	call	LCD_cmd
	call    LCD_rdy
	call	Columna1
	movff	POSTINC0, WREG
	call    send2LCD
	call	Columna1
	movff	POSTINC0, WREG
	call    send2LCD
	movlw	0xCB
	call	LCD_cmd
	call    LCD_rdy
	call	Columna1
	movff	POSTINC0, WREG
	call    send2LCD
		
here:;	while( 1 ){	
	
	goto    here;		}
	
Columna1:
    movlw   0b01110000
    movwf   LATB, A
F1_1:    
    btfsc   PORTB, 0, A
    bra     F1_2
    movlw   '/'
    movwf   INDF0, A
    call    release1
    goto    end_key

F1_2:
    btfsc   PORTB, 1, A
    bra     F1_3
    movlw   'X'
    movwf   INDF0, A
    call    release2
    goto    end_key

F1_3:
    btfsc   PORTB, 2, A
    bra     F1_4
    movlw   '-'
    movwf   INDF0, A
    call    release3
    goto    end_key

F1_4:
    btfsc   PORTB, 3, A
    bra     Columna2
    movlw   '+'
    movwf   INDF0, A
    call    release4
    goto    end_key

Columna2:
    movlw   0b10110000
    movwf   LATB, A
F2_1:    
    btfsc   PORTB, 0, A
    bra     F2_2
    movlw   '9'
    movwf   INDF0, A
    call    release1
    goto    end_key

F2_2:
    btfsc   PORTB, 1, A
    bra     F2_3
    movlw   '6'
    movwf   INDF0, A
    call    release2
    goto    end_key

F2_3:
    btfsc   PORTB, 2, A
    bra     F2_4
    movlw   '3'
    movwf   INDF0, A
    call    release3
    goto    end_key

F2_4:
    btfsc   PORTB, 3, A
    bra     Columna3
    movlw   '='
    movwf   INDF0, A
    call    release4
    goto    end_key

Columna3:
    movlw   0b11010000
    movwf   LATB, A
F3_1:
    btfsc   PORTB, 0, A
    bra     F3_2
    movlw   '8'
    movwf   INDF0, A
    call    release1
    goto    end_key

F3_2:
    btfsc   PORTB, 1, A
    bra     F3_3
    movlw   '5'
    movwf   INDF0, A
    call    release2
    goto    end_key

F3_3:
    btfsc   PORTB, 2, A
    bra     F3_4
    movlw   '2'
    movwf   INDF0, A
    call    release3
    goto    end_key

F3_4:
    btfsc   PORTB, 3, A
    bra     Columna4
    movlw   '0'
    movwf   INDF0, A
    call    release4
    goto    end_key

Columna4:
    movlw   0b11100000
    movwf   LATB, A
F4_1:
    btfsc   PORTB, 0, A
    bra     F4_2
    movlw   '7'
    movwf   INDF0, A
    call    release1
    goto    end_key

F4_2:
    btfsc   PORTB, 1, A
    bra     F4_3
    movlw   '4'
    movwf   INDF0, A
    call    release2
    goto    end_key

F4_3:
    btfsc   PORTB, 2, A
    bra     F4_4
    movlw   '1'
    movwf   INDF0, A
    call    release3
    goto    end_key

F4_4:
    btfsc   PORTB, 3, A
    bra     Columna1
    movlw   'R'
    movwf   INDF0, A
    call    release4
    goto    end_key
	
end_key:
	return
	
portsInit:
	movlb	BANK15
	movlw	oscillator1MHz
	movwf	OSCCON, A
	clrf	ANSELD,B
	bcf	ANSELC,0,B
	bcf	ANSELC,1,B
	bcf	ANSELC,2,B
	movlw	0x0F
	movwf	WPUB, B
	movwf	TRISB, A
	clrf	ANSELB, B
	clrf	LATB, A
	bcf	INTCON2, 7, B
	
	return

LCD_rdy: 
	setf	LCD_D_DIR	; configure LCD data port for input
	bcf	LCD_RS		; select IR register
	bsf	LCD_RW		; setup to read busy flag
	bsf	LCD_E		; pull LCD E-line to high
	movf	LCD_DATA,W,A	; read busy flag and DDRAM address
	nop
	bcf	LCD_E		; small delay to lengthen E pulse
	btfsc	WREG,7,A	; pull LCD E-line to low
	goto	LCD_rdy		; is busy flag (BF) cleared
	clrf	LCD_D_DIR	; configure data pins for output
	return

LCD_cmd:
        movff WREG,0x000
	call LCD_rdy ; wait until LCD is ready
	bcf LCD_RS ; select IR register
	bcf LCD_RW ; Set write mode
	bsf LCD_E ; Setup to clock data
	movff 0x000,WREG
	movwf LCD_DATA,A ; send out the command in WREG
	nop ; small delay to lengthen E pulse
	bcf LCD_E
	return

LCD_init:
	clrf LCD_ctl_port ; make sure the LCD control port is low
	bcf LCD_E_DIR ; configure control lines
	bcf LCD_RW_DIR ; directions to output
	bcf LCD_RS_DIR
	movlw 0x3C ; configure display to 2x40
	call LCD_cmd ; send command to LCD
	movlw 0x0F ; turn on display and cursor
	call LCD_cmd 
	movlw 0x14 ; shift cursor right
	call LCD_cmd 
	movlw 0x01 ; clear cursor a~rdetu rn to home position
	call LCD_cmd   
	return
	
send2LCD:
	bsf LCD_RS ; select DR register
	bcf LCD_RW ; Set write mode
	bsf LCD_E ; Setup to clock data
	movwf LCD_DATA,A ; write into LCD DR
	nop ; a short delay
	bcf LCD_E
	return
	
release1:   
	btfss   BUTTON1;		    test if button is released (1)
	bra     release1;		    if no released, check again
	call    delay_20ms;	    delay of 20 ms
	bsf     LATA, 0, A;	    clean signal that emulates the release
	return
	
release2:   
	btfss   BUTTON2;		    test if button is released (1)
	bra     release2;		    if no released, check again
	call    delay_20ms;	    delay of 20 ms
	bsf     LATA, 0, A;	    clean signal that emulates the release
	return

release3:   
	btfss   BUTTON3;		    test if button is released (1)
	bra     release3;		    if no released, check again
	call    delay_20ms;	    delay of 20 ms
	bsf     LATA, 0, A;	    clean signal that emulates the release
	return

release4:   
	btfss   BUTTON4;		    test if button is released (1)
	bra     release4;		    if no released, check again
	call    delay_20ms;	    delay of 20 ms
	bsf     LATA, 0, A;	    clean signal that emulates the release
	return
	
delay_20ms:
	movlw   count20ms_high
	movwf   TMR1H, A;	    load initial count, high-byte first
	movlw   count20ms_low
	movwf   TMR1L, A;	    then low-byte
	bcf     PIR1, 0, A;	    clear the Timer 1 overflow flag
	movlw   timerInit20ms;	    initialize Timer 1 with:
	movwf   T1CON, A;	    mode=16bit, internal clock, not prescaler
	bsf     ENABLER_TMR1;	    enables Timer 1
notovf: btfss   PIR1, 0, A
	bra     notovf;	    	    wait for Timer 1 overflow
	bcf     ENABLER_TMR1;	    stop Timer 1
	return
	
Pantalla1:
	movlw	0x80
	call	LCD_cmd
	call    LCD_rdy
	movlw   'T'
	call    send2LCD
	movlw   'e'
	call    send2LCD
	movlw   'm'
	call    send2LCD
	movlw   'p'
	call    send2LCD
	movlw   'e'
	call    send2LCD
	movlw   'r'
	call    send2LCD
	movlw   'a'
	call    send2LCD
	movlw   't'
	call    send2LCD
	movlw   'u'
	call    send2LCD
	movlw   'r'
	call    send2LCD
	movlw   'a'
	call    send2LCD
	
	movlw	0xC0
	call	LCD_cmd
	call    LCD_rdy
	movlw   'D'
	call    send2LCD
	movlw   'e'
	call    send2LCD
	movlw   's'
	call    send2LCD
	movlw   'e'
	call    send2LCD
	movlw   'a'
	call    send2LCD
	movlw   'd'
	call    send2LCD
	movlw   'a'
	call    send2LCD
	movlw   ':'
	call    send2LCD
	movlw   '_'
	call    send2LCD
	movlw   '_'
	call    send2LCD
	movlw   '.'
	call    send2LCD
	movlw   '_'
	call    send2LCD
	movlw   'C'
	call    send2LCD
	return
